<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generalized Method of Moments · MethodOfMoments.jl</title><meta name="title" content="Generalized Method of Moments · MethodOfMoments.jl"/><meta property="og:title" content="Generalized Method of Moments · MethodOfMoments.jl"/><meta property="twitter:title" content="Generalized Method of Moments · MethodOfMoments.jl"/><meta name="description" content="Documentation for MethodOfMoments.jl."/><meta property="og:description" content="Documentation for MethodOfMoments.jl."/><meta property="twitter:description" content="Documentation for MethodOfMoments.jl."/><meta property="og:url" content="https://junyuan-chen.github.io/MethodOfMoments.jl/stable/man/nonlineargmm/"/><meta property="twitter:url" content="https://junyuan-chen.github.io/MethodOfMoments.jl/stable/man/nonlineargmm/"/><link rel="canonical" href="https://junyuan-chen.github.io/MethodOfMoments.jl/stable/man/nonlineargmm/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MethodOfMoments.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Generalized Method of Moments</a><ul class="internal"><li><a class="tocitem" href="#Nonlinear-Iterated-GMM-Estimator"><span>Nonlinear Iterated GMM Estimator</span></a></li><li><a class="tocitem" href="#Example:-Exponential-Regression-with-Instruments"><span>Example: Exponential Regression with Instruments</span></a></li><li><a class="tocitem" href="#Specifying-Moment-Conditions-and-Their-Derivatives"><span>Specifying Moment Conditions and Their Derivatives</span></a></li><li><a class="tocitem" href="#Specifying-Variance-Covariance-Estimator"><span>Specifying Variance-Covariance Estimator</span></a></li><li><a class="tocitem" href="#Obtaining-the-Estimation-Results"><span>Obtaining the Estimation Results</span></a></li><li><a class="tocitem" href="#Implementation-Details"><span>Implementation Details</span></a></li></ul></li><li><a class="tocitem" href="../lineargmm/">Linear GMM</a></li><li><a class="tocitem" href="../bayesian/">Bayesian Quasi-Likelihood</a></li></ul></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Generalized Method of Moments</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generalized Method of Moments</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/junyuan-chen/MethodOfMoments.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/junyuan-chen/MethodOfMoments.jl/blob/main/docs/src/man/nonlineargmm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Generalized-Method-of-Moments"><a class="docs-heading-anchor" href="#Generalized-Method-of-Moments">Generalized Method of Moments</a><a id="Generalized-Method-of-Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Method-of-Moments" title="Permalink"></a></h1><p>In general, a GMM estimator chooses the point estimate <span>$\theta$</span> by minimizing the following criterion function</p><p class="math-container">\[Q(\theta) = \left[\frac{1}{N}\sum_{i=1}^N \mathbf{g}_i(\theta)\right]&#39;\mathbf{W}\left[\frac{1}{N}\sum_{i=1}^N \mathbf{g}_i(\theta)\right]\]</p><p>where <span>$\mathbf{g}_i(\theta)$</span> is a vector of residuals from evaluating the moment conditions with parameter vector <span>$\theta$</span> and observation <code>i</code> of a sample consisting of <span>$N$</span> observations. When the number of moment conditions (length of <span>$\mathbf{g}_i(\theta)$</span>) is greater than the number of parameters (length of <span>$\theta$</span>), the parameters are <strong>over-identified</strong>. In this case, <span>$\mathbf{W}$</span> is a weight matrix affecting the relative importance of each moment conditions for the criterion. When the number of moment conditions matches the number of parameters, the weight matrix is irrelevant and the parameters are <strong>just-identified</strong>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><h2 id="Nonlinear-Iterated-GMM-Estimator"><a class="docs-heading-anchor" href="#Nonlinear-Iterated-GMM-Estimator">Nonlinear Iterated GMM Estimator</a><a id="Nonlinear-Iterated-GMM-Estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Iterated-GMM-Estimator" title="Permalink"></a></h2><p>An iterated GMM estimator is implemented for some arbitrary moment conditions provided by users. This allows estimating nonlinear GMM via the iterative method considered in <a href="../../refs/#HansenHY96F">Hansen <em>et al.</em> (1996)</a>. In particular, the <strong>two-step GMM estimator</strong> is a special case where the number of iterations is restricted to two.</p><p>Starting from an initial weight matrix <span>$\mathbf{W}^{(1)}$</span>, the iterated GMM estimator iterates through the following steps for <span>$k\geq 1$</span>:</p><ol><li>Given a weight matrix <span>$\mathbf{W}^{(k)}$</span>, find <span>$\theta^{(k)}$</span> that minimizes the criterion function.</li><li>Given the minimizer <span>$\theta^{(k)}$</span>, compute a new weight matrix <span>$\mathbf{W}^{(k+1)}$</span> using the inverse of the variance-covariance matrix estimated from the moment conditions <span>$\mathbf{g}_i(\theta^{(k)})$</span> for each <span>$i$</span>.</li></ol><p>The above iterations continue until one of the two conditions are met:</p><ol><li><span>$\theta^{(k+1)}$</span> is sufficiently close to <span>$\theta^{(k)}$</span>.</li><li>A maximum number of iterations is reached.</li></ol><h2 id="Example:-Exponential-Regression-with-Instruments"><a class="docs-heading-anchor" href="#Example:-Exponential-Regression-with-Instruments">Example: Exponential Regression with Instruments</a><a id="Example:-Exponential-Regression-with-Instruments-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Exponential-Regression-with-Instruments" title="Permalink"></a></h2><p>To illustrate the use of such an estimator, we replicate <a href="https://www.stata.com/manuals/rgmm.pdf">Example 8</a> from Stata manual for <code>gmm</code>. The data for this example are included in <a href="https://github.com/junyuan-chen/MethodOfMoments.jl">MethodOfMoments.jl</a> for convenience and can be loaded as below:</p><pre><code class="language-julia hljs">using MethodOfMoments, CSV, DataFrames, TypedTables
# exampledata loads data from CSV files bundled with MethodOfMoments.jl
exampledata(name::Union{Symbol,String}) =
    DataFrame(CSV.read(MethodOfMoments.datafile(name), DataFrame), copycols=true)

data = Table(exampledata(:docvisits))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Table with 10 columns and 4412 rows:
      docvis  age  income   female  black  hispanic  married  physlim  ⋯
    ┌───────────────────────────────────────────────────────────────────
 1  │ 0       3.9  30.0     1       0      1         1        0        ⋯
 2  │ 1       4.7  10.0     0       0      1         1        0        ⋯
 3  │ 15      2.7  27.0     1       0      0         0        0        ⋯
 4  │ 0       3.0  11.25    0       0      0         1        0        ⋯
 5  │ 2       5.4  76.33    1       0      0         1        0        ⋯
 6  │ 2       6.0  185.557  0       0      0         1        0        ⋯
 7  │ 0       2.8  7.6      0       0      0         0        0        ⋯
 8  │ 0       4.2  14.0     1       0      0         0        0        ⋯
 9  │ 1       3.2  59.897   0       0      0         1        0        ⋯
 10 │ 0       4.8  17.1     0       0      0         1        0        ⋯
 11 │ 0       2.6  14.04    0       0      1         1        0        ⋯
 12 │ 0       3.9  23.92    0       0      1         1        0        ⋯
 13 │ 5       2.6  20.26    1       0      1         1        0        ⋯
 14 │ 2       3.4  75.0     0       0      0         1        0        ⋯
 15 │ 0       4.1  23.791   1       0      1         0        0        ⋯
 16 │ 1       3.7  43.5     0       0      1         1        0        ⋯
 17 │ 3       2.7  60.905   1       0      0         0        0        ⋯
 ⋮  │   ⋮      ⋮      ⋮       ⋮       ⋮       ⋮         ⋮        ⋮     ⋱</code></pre><p>Above, the data frame is converted to a <code>Table</code> from <a href="https://github.com/JuliaData/TypedTables.jl">TypedTables.jl</a> for a convenient syntax of evaluating moment conditions by row while being fast.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is important to clean the sample before conducting estimation. The estimator does not handle invalid values such as <code>missing</code> and <code>NaN</code> when evaluating the moment conditions.</p></div></div><p>For this example, the moment conditions can be written as</p><p class="math-container">\[\mathrm{E}[\mathbf{g}_i(\theta)] =
\mathrm{E}\left[ (Y_i - \exp(\theta&#39;\mathbf{X}_i)) \mathbf{Z}_i  \right] = \mathbf{0}\]</p><p>where the residual from the structural equation</p><p class="math-container">\[Y_i = \exp(\theta&#39;\mathbf{X}_i) + \varepsilon_i\]</p><p>is assumed to be orthogonal to a vector of instruments <span>$\mathbf{Z}_i$</span>.</p><h2 id="Specifying-Moment-Conditions-and-Their-Derivatives"><a class="docs-heading-anchor" href="#Specifying-Moment-Conditions-and-Their-Derivatives">Specifying Moment Conditions and Their Derivatives</a><a id="Specifying-Moment-Conditions-and-Their-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Moment-Conditions-and-Their-Derivatives" title="Permalink"></a></h2><p>The moment conditions and their derivatives with respect to the parameters need to be provided as Julia functions that are going to be evaluated for individual observations. They are required to accept the parameters as the first argument and the row index of the data frame as the second argument. For the moment conditions, the function should return the residuals from evaluating the moment conditions for a specific observation as an iterable object such as a <code>Tuple</code> or a static vector <code>SVector</code>. For the derivatives, the function should return a Jacobian matrix with rows corresponding to the moment conditions and columns corresponding to the parameters.</p><p>For example, the moment conditions could be defined as follows:</p><pre><code class="language-julia hljs">using StaticArrays

struct g_stata_gmm_ex8{D}
    data::D
end

function (g::g_stata_gmm_ex8)(θ, r)
    @inbounds d = g.data[r]
    x = SVector{5,Float64}((d.private, d.chronic, d.female, d.income, 1.0))
    z = SVector{7,Float64}((d.private, d.chronic, d.female, d.age, d.black, d.hispanic, 1.0))
    return (d.docvis - exp(θ&#39;x)) .* z
end</code></pre><p>Notice that since such functions typically need to retrieve values from a data frame that is not an argument of the functions, a <code>struct</code> wrapping the data frame has been defined and a method is attached to the struct following the requirement for the arguments.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Illustrations for adding a method to a <code>struct</code> is available <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">here</a> from Julia documentation.</p></div></div><p>To simplify the above definition, a macro <code>@dgd</code> is provided. This allows defining a <code>struct</code> as in the above example by prepending <code>@dgd</code> to the function definition without typing the definition for the <code>struct</code>:</p><pre><code class="language-julia hljs">using StaticArrays

@gdg function (g::g_stata_gmm_ex8)(θ, r)
    @inbounds d = g.data[r]
    x = SVector{5,Float64}((d.private, d.chronic, d.female, d.income, 1.0))
    z = SVector{7,Float64}((d.private, d.chronic, d.female, d.age, d.black, d.hispanic, 1.0))
    return (d.docvis - exp(θ&#39;x)) .* z
end

g = g_stata_gmm_ex8(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">g_stata_gmm_ex8 (functor defined with @gdg for moment conditions)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Using <code>SVector</code> from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> instead of <code>Vector</code> avoids memory allocations while preserving the syntax for array operations.</p></div></div><p>For minimizing the criterion function and computing the variance-covariance matrix, we additionally require the derivatives of the moment conditions with respect to each parameter. They can be defined in a similar fashion as below:</p><pre><code class="language-julia hljs">@gdg function (dg::dg_stata_gmm_ex8)(θ, r)
    @inbounds d = dg.data[r]
    x = SVector{5,Float64}((d.private, d.chronic, d.female, d.income, 1.0))
    z = SVector{7,Float64}((d.private, d.chronic, d.female, d.age, d.black, d.hispanic, 1.0))
    return z .* (- exp(θ&#39;x) .* x&#39;)
end

dg = dg_stata_gmm_ex8(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">dg_stata_gmm_ex8 (functor defined with @gdg for moment conditions)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The users are expected to order the parameters and moment conditions consistently. An index <code>k</code> for a parameter should always refer to the same parameter whenever a vector of parameters is involved. A similar requirement holds for the moment conditions.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The performance of these functions evaluating the moment conditions and their derivatives is important for the run time of the estimator, especially when the sample size is large. The users are recommended to profile these functions to ensure they have acceptable performance. Ideally, these functions should be non-allocating and type stable.</p></div></div><h2 id="Specifying-Variance-Covariance-Estimator"><a class="docs-heading-anchor" href="#Specifying-Variance-Covariance-Estimator">Specifying Variance-Covariance Estimator</a><a id="Specifying-Variance-Covariance-Estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Variance-Covariance-Estimator" title="Permalink"></a></h2><p>A variance-covariance estimator (VCE) provides information for inference. With the iterated GMM estimator, the VCE additionally instructs how the weight matrix <span>$\mathbf{W}^{(k)}$</span> is updated in each iteration.</p><p><a href="https://github.com/junyuan-chen/MethodOfMoments.jl">MethodOfMoments.jl</a> implements two VCEs:</p><ol><li>The Eicker-Huber-White heteroskedasticity-robust VCE.</li><li>The multiway cluster-robust VCE as in <a href="../../refs/#CameronGM11R">Cameron <em>et al.</em> (2011)</a>.</li></ol><p>Here, we specify the heteroskedasticity-robust VCE by constructing a <code>RobustVCE</code>, specifying the numbers of parameters, moment conditions and observations as arguments:</p><pre><code class="language-julia hljs">vce = RobustVCE(5, 7, length(data))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Heteroskedasticity-robust covariance estimator</code></pre><h2 id="Obtaining-the-Estimation-Results"><a class="docs-heading-anchor" href="#Obtaining-the-Estimation-Results">Obtaining the Estimation Results</a><a id="Obtaining-the-Estimation-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-the-Estimation-Results" title="Permalink"></a></h2><p>We are now ready to conduct the estimation:</p><pre><code class="language-julia hljs"># Specify parameter names
params = (:private, :chronic, :female, :income, :cons)
# Conduct the estimation
r = fit(IteratedGMM, Hybrid, vce, g, dg, params, 7, length(data), maxiter=2, ntasks=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonlinearGMM with 7 moments and 5 parameters:
  Iterated GMM estimator:
    iter   2  =&gt;  Q(θ) = 1.58235e-03  max|θ-θlast| = 1.50185e-01
                  Jstat = 6.98        Pr(&gt;J) = 0.0305
  Heteroskedasticity-robust covariance estimator
───────────────────────────────────────────────────────────────────────
           Estimate  Std. Error      z  Pr(&gt;|z|)   Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────
private   0.481712   0.161302     2.99    0.0028   0.165565    0.797858
chronic   1.07941    0.0639269   16.89    &lt;1e-63   0.954116    1.2047
female    0.694048   0.102188     6.79    &lt;1e-10   0.493762    0.894334
income    0.0152984  0.00267279   5.72    &lt;1e-07   0.0100598   0.020537
cons     -0.619071   0.139927    -4.42    &lt;1e-05  -0.893322   -0.34482
───────────────────────────────────────────────────────────────────────</code></pre><p>We have specified the estimator by providing <code>IteratedGMM</code> as the first argument. For minimizing the criterion function, we have used the <code>Hybrid</code> solver from <a href="https://github.com/junyuan-chen/NonlinearSystems.jl">NonlinearSystems.jl</a>, which is a native Julia implementation of the hybrid method from MINPACK with minor revisions. With the keyword argument <code>maxiter=2</code>, we only conduct two steps for the iteration. The moment conditions across observations are evaluated in parallel with two threads specified with <code>ntasks=2</code>. If <code>ntasks</code> is not specified, a default value will be determined based on the sample size.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The <code>Hybrid</code> solver from <a href="https://github.com/junyuan-chen/NonlinearSystems.jl">NonlinearSystems.jl</a> is the only solver bundled with <a href="https://github.com/junyuan-chen/MethodOfMoments.jl">MethodOfMoments.jl</a> at this moment. It is possible to swap the solver, although that should be unnecessary in typical use cases.</p></div></div><p>Interface for retrieving the estimation results is defined following <a href="https://github.com/JuliaStats/StatsAPI.jl">StatsAPI.jl</a>. For example, to obtain the point estimates:</p><pre><code class="language-julia hljs">coef(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
  0.4817116025899292
  1.0794101667721612
  0.6940481040440498
  0.015298386177060077
 -0.6190709065124277</code></pre><p>To obtain the standard errors:</p><pre><code class="language-julia hljs">stderror(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 0.16130239107187994
 0.0639268930566725
 0.10218843457177068
 0.00267278817868127
 0.13992674433494878</code></pre><p>To obtain 90% confidence intervals:</p><pre><code class="language-julia hljs">lb, ub = confint(r; level=0.9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.21639277959940278, 0.9742597848681546, 0.5259630868061796, 0.010902040847283172, -0.8492299194392795], [0.7470304255804556, 1.184560548676168, 0.86213312128192, 0.019694731506836982, -0.3889118935855759])</code></pre><p>When the parameters are over-identified, the Hansen&#39;s <span>$J$</span> statistic can be retrieved:</p><pre><code class="language-julia hljs">Jstat(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6.981309043786015</code></pre><h2 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h2><p>Instead of literally solving a minimization problem defined with the scalar-valued criterion function <span>$Q(\theta)$</span>, the estimator solves a least squares problem for the vector-valued moment conditions after adjusting the weights using the <code>Hybrid</code> solver designed for systems of nonlinear equations. This relies on the assumption that the weight matrix should always be positive definite and hence can be decomposed as a product of a triangular matrix and its conjugate transpose with Cholesky decomposition. This approach tends to be much faster than solving the scalar-valued problem, as it exploits more information from the Jacobian matrix of the moment conditions relative to the gradient vector for the scalar-valued problem.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>A suitable rank condition is assumed for discussing the number of moment conditions to be meaningful.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../lineargmm/">Linear GMM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 13 November 2024 00:09">Wednesday 13 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
